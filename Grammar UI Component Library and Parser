import React, { useState } from 'react';
import * as Icons from 'lucide-react';

// Design tokens
const tokens = {
  colors: {
    bgBase: 'var(--background-primary, #000)',
    bgSurface: 'var(--background-secondary, #0a0a0a)',
    bgHover: 'var(--background-modifier-hover, #0f0f0f)',
    border: 'var(--background-modifier-border, #1a1a1a)',
    textBright: 'var(--text-normal, #ccc)',
    textMid: 'var(--text-muted, #999)',
    textDim: 'var(--text-faint, #666)',
    textMuted: 'var(--text-faint, #555)',
    iconPrimary: 'var(--icon-color, #666)',
    iconDim: 'var(--icon-color-focused, #555)',
    iconBright: 'var(--icon-color-hover, #888)',
    accent: 'var(--interactive-accent, #7c3aed)',
  },
  spacing: {
    xs: '4px',
    sm: '6px',
    md: '8px',
    lg: '12px',
    xl: '16px',
    '2xl': '24px',
    '3xl': '32px',
  },
  fontSize: {
    xs: '12px',
    sm: '13px',
    base: '14px',
    lg: '16px',
    xl: '18px',
  },
  radius: {
    sm: '3px',
    md: '4px',
  },
  transition: '150ms ease',
};

// Text Component
export const Text = ({ 
  size = 'base', 
  color = 'mid', 
  weight = 'normal',
  mono = false,
  children,
  style = {}
}) => {
  const colorMap = {
    bright: tokens.colors.textBright,
    mid: tokens.colors.textMid,
    dim: tokens.colors.textDim,
    muted: tokens.colors.textMuted,
  };

  return (
    <div style={{
      fontSize: tokens.fontSize[size],
      color: colorMap[color],
      fontWeight: weight === 'medium' ? 500 : 400,
      fontFamily: mono ? 'monospace' : 'inherit',
      lineHeight: '1.5',
      ...style
    }}>
      {children}
    </div>
  );
};

// Icon Component
export const Icon = ({ name, size = 14, color = 'primary' }) => {
  if (!name) return null;
  
  const pascalName = name.split('-').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
  ).join('');
  
  const IconComponent = Icons[pascalName];
  
  if (!IconComponent) {
    console.warn(`Icon "${name}" (${pascalName}) not found in lucide-react`);
    return null;
  }

  const colorMap = {
    primary: tokens.colors.iconPrimary,
    dim: tokens.colors.iconDim,
    bright: tokens.colors.iconBright,
  };

  return <IconComponent size={size} color={colorMap[color]} style={{ flexShrink: 0, marginTop: '2px' }} />;
};

// NEW: Badge Component
export const Badge = ({ children, variant = 'default' }) => {
  const variants = {
    default: { bg: tokens.colors.bgSurface, color: tokens.colors.textDim },
    accent: { bg: tokens.colors.accent + '20', color: tokens.colors.accent },
    success: { bg: '#3a4a3a', color: '#5a7a5a' },
    error: { bg: '#4a3a3a', color: '#7a5a5a' },
  };

  const style = variants[variant] || variants.default;

  return (
    <span style={{
      display: 'inline-flex',
      alignItems: 'center',
      padding: `2px ${tokens.spacing.sm}`,
      background: style.bg,
      color: style.color,
      fontSize: tokens.fontSize.sm,
      borderRadius: tokens.radius.sm,
      border: '1px solid rgba(255,255,255,0.05)',
    }}>
      {children}
    </span>
  );
};

// NEW: Card Component
export const Card = ({ children, hover = false, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  return (
    <div
      onClick={onClick}
      onMouseEnter={() => hover && setIsHovered(true)}
      onMouseLeave={() => hover && setIsHovered(false)}
      style={{
        border: `1px solid ${tokens.colors.border}`,
        borderRadius: tokens.radius.md,
        background: isHovered ? tokens.colors.bgHover : tokens.colors.bgSurface,
        padding: tokens.spacing.lg,
        cursor: hover ? 'pointer' : 'default',
        transition: `all ${tokens.transition}`,
      }}
    >
      {children}
    </div>
  );
};

// NEW: Stack Component (simpler than Grid)
export const Stack = ({ direction = 'vertical', gap = 'md', align = 'stretch', children, style = {} }) => {
  return (
    <div style={{
      display: 'flex',
      flexDirection: direction === 'vertical' ? 'column' : 'row',
      gap: tokens.spacing[gap],
      alignItems: align,
      ...style
    }}>
      {children}
    </div>
  );
};

// NEW: Link Component
export const Link = ({ icon, href, onClick, children }) => {
  const [isHovered, setIsHovered] = useState(false);

  return (
    <a
      href={href}
      onClick={(e) => {
        if (onClick) {
          e.preventDefault();
          onClick();
        }
      }}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        gap: tokens.spacing.xs,
        color: isHovered ? tokens.colors.textBright : tokens.colors.textMid,
        textDecoration: 'none',
        fontSize: tokens.fontSize.sm,
        cursor: 'pointer',
        transition: `color ${tokens.transition}`,
      }}
    >
      {icon && <Icon name={icon} size={12} />}
      {children}
    </a>
  );
};

// Grid Component
export const Grid = ({ 
  cols = '1',
  gap = 'md',
  min,
  align = 'center',
  justify = 'start',
  border = false,
  background = false,
  padding,
  hover = false,
  collapsible = false,
  defaultExpanded = false,
  previewLines = 2,
  children,
  style = {}
}) => {
  const [isHovered, setIsHovered] = useState(false);
  const [isExpanded, setIsExpanded] = useState(defaultExpanded);

  const childArray = React.Children.toArray(children);
  const visibleChildren = collapsible && !isExpanded 
    ? childArray.slice(0, previewLines) 
    : childArray;
  const hasMore = collapsible && childArray.length > previewLines;

  let gridCols;
  if (cols === 'auto') {
    gridCols = 'auto';
  } else if (cols === 'auto-fit') {
    const minWidth = min || '120px';
    gridCols = `repeat(auto-fit, minmax(${minWidth}, 1fr))`;
  } else {
    gridCols = cols === '1' ? '1fr' : `repeat(${cols}, 1fr)`;
  }

  const baseStyle = {
    display: 'grid',
    gridTemplateColumns: gridCols,
    gridAutoFlow: cols === 'auto' ? 'column' : 'row',
    gap: tokens.spacing[gap],
    alignItems: align,
    justifyContent: justify,
    ...(border && { border: `1px solid ${tokens.colors.border}` }),
    ...(background && { background: tokens.colors.bgSurface }),
    ...(padding && { padding: tokens.spacing[padding] }),
    ...(border && { borderRadius: tokens.radius.md }),
    ...(hover && isHovered && { background: tokens.colors.bgHover }),
    ...(hover && { cursor: 'pointer' }),
    transition: `all ${tokens.transition}`,
    ...style
  };

  const content = (
    <>
      {collapsible ? (
        <div style={{ display: 'grid', gridTemplateColumns: '1fr auto', gap: '8px', gridColumn: '1 / -1' }}>
          <div style={{ display: 'grid', gridTemplateColumns: gridCols, gap: tokens.spacing[gap] }}>
            {visibleChildren}
          </div>
          <Icons.ChevronRight 
            size={12} 
            color={tokens.colors.iconDim}
            style={{
              transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)',
              transition: `transform ${tokens.transition}`,
              marginTop: '2px',
              flexShrink: 0
            }}
          />
        </div>
      ) : (
        visibleChildren
      )}
      {collapsible && isExpanded && hasMore && (
        <>
          <div style={{ 
            gridColumn: '1 / -1',
            height: '1px',
            background: tokens.colors.border,
            margin: `${tokens.spacing.md} 0`
          }} />
          {childArray.slice(previewLines)}
        </>
      )}
    </>
  );

  return (
    <div 
      style={baseStyle}
      onMouseEnter={() => hover && setIsHovered(true)}
      onMouseLeave={() => hover && setIsHovered(false)}
      onClick={() => collapsible && setIsExpanded(!isExpanded)}
    >
      {content}
    </div>
  );
};

// Button Component
export const Button = ({ icon, primary = false, onClick, children, ariaLabel }) => {
  const [isHovered, setIsHovered] = useState(false);

  return (
    <button
      onClick={onClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      aria-label={ariaLabel}
      style={{
        background: isHovered ? tokens.colors.bgHover : 'none',
        border: 'none',
        color: isHovered ? (primary ? tokens.colors.textBright : tokens.colors.textMid) : (primary ? tokens.colors.textMid : tokens.colors.textDim),
        fontSize: tokens.fontSize.sm,
        cursor: 'pointer',
        padding: `${tokens.spacing.sm} ${tokens.spacing.md}`,
        borderRadius: tokens.radius.sm,
        display: 'flex',
        alignItems: 'center',
        gap: tokens.spacing.sm,
        transition: `all ${tokens.transition}`,
      }}
    >
      {icon && <Icon name={icon} size={12} />}
      <span>{children}</span>
    </button>
  );
};

// Divider Component
export const Divider = ({ direction = 'h', space = 'lg' }) => {
  const isHorizontal = direction === 'h';
  
  return (
    <div style={{
      ...(isHorizontal ? {
        height: '1px',
        width: '100%',
        margin: `${tokens.spacing[space]} 0`,
        gridColumn: '1 / -1'
      } : {
        width: '1px',
        height: '100%',
        margin: `0 ${tokens.spacing[space]}`
      }),
      background: tokens.colors.border,
    }} />
  );
};

// ListItem Component
export const ListItem = ({ icon, hover = true, onClick, children }) => {
  const [isHovered, setIsHovered] = useState(false);

  return (
    <div
      onClick={onClick}
      onMouseEnter={() => hover && setIsHovered(true)}
      onMouseLeave={() => hover && setIsHovered(false)}
      style={{
        display: 'grid',
        gridTemplateColumns: icon ? 'auto 1fr' : '1fr',
        alignItems: 'start',
        gap: tokens.spacing.md,
        padding: `${tokens.spacing.md} 0`,
        background: isHovered ? tokens.colors.bgHover : 'transparent',
        ...(isHovered && {
          paddingLeft: tokens.spacing.md,
          paddingRight: tokens.spacing.md,
          marginLeft: `-${tokens.spacing.md}`,
          marginRight: `-${tokens.spacing.md}`,
        }),
        cursor: hover ? 'pointer' : 'default',
        transition: `all ${tokens.transition}`,
      }}
    >
      {icon && <Icon name={icon} size={12} color="dim" />}
      <div style={{ minWidth: 0 }}>{children}</div>
    </div>
  );
};

// Status Component
export const Status = ({ type = 'info', children }) => {
  const config = {
    success: { icon: 'CheckCircle', bg: '#3a4a3a', iconColor: '#5a7a5a' },
    error: { icon: 'XCircle', bg: '#4a3a3a', iconColor: '#7a5a5a' },
    pending: { icon: 'Clock', bg: '#4a4a3a', iconColor: '#7a7a5a' },
    info: { icon: 'AlertCircle', bg: '#3a3a4a', iconColor: '#5a5a7a' },
  };

  const { icon, bg, iconColor } = config[type];
  const IconComp = Icons[icon];

  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      gap: tokens.spacing.md,
      padding: `${tokens.spacing.md} ${tokens.spacing.lg}`,
      background: bg,
      border: '1px solid rgba(255,255,255,0.05)',
      borderRadius: tokens.radius.sm,
    }}>
      <IconComp size={14} color={iconColor} style={{ flexShrink: 0 }} />
      <Text size="sm" color="mid">{children}</Text>
    </div>
  );
};

// Spinner Component
export const Spinner = () => {
  return (
    <div style={{
      width: '14px',
      height: '14px',
      border: '1px solid #222',
      borderTopColor: tokens.colors.iconPrimary,
      borderRadius: '50%',
      animation: 'spin 1s linear infinite',
    }} />
  );
};

// ENHANCED: Parse props with better type conversion
const parseProps = (propsStr) => {
  const props = {};
  if (!propsStr) return props;
  
  propsStr.split(',').forEach(prop => {
    const [key, ...valParts] = prop.trim().split('-');
    const rawVal = valParts.join('-');
    
    // Type conversion
    let val;
    if (rawVal === '') val = true;
    else if (rawVal === 'true') val = true;
    else if (rawVal === 'false') val = false;
    else if (!isNaN(rawVal) && rawVal !== '') val = Number(rawVal);
    else val = rawVal;
    
    props[key] = val;
  });
  
  return props;
};

// SEMANTIC LAYER: Expand high-level patterns into low-level grammar
const expandSemanticPattern = (pattern) => {
  // Match semantic pattern: [semantic-type:key-val,key-val]
  const match = pattern.match(/^\[(file-result|search-result|tag-group|stat-card|file-list-item):(.*?)\]/);
  if (!match) return null;
  
  const [, type, propsStr] = match;
  const props = parseProps(propsStr);
  
  switch (type) {
    case 'file-result':
      return `[card]
  [stack:gap-sm]
    [grid:cols-auto,gap-sm]
      [icon:name-file-text,size-14,color-dim]
      [text:size-sm,color-bright] ${props.path || 'Untitled'}
    [/grid]
    ${props.tags ? `[grid:cols-auto,gap-sm]
      [icon:name-tag,size-12,color-dim]
      [text:size-sm,color-dim] ${props.tags}
    [/grid]` : ''}
    ${props.modified ? `[grid:cols-auto,gap-sm]
      [icon:name-clock,size-12,color-dim]
      [text:size-sm,color-dim] ${props.modified}
    [/grid]` : ''}
  [/stack]
[/card]
[grid:cols-auto,gap-sm]
  [button:icon-external-link,action-open] Open file
  [button:icon-link,action-view-links] View links
[/grid]`;

    case 'search-result':
      return `[card:hover-true]
  [stack:gap-sm]
    [grid:cols-auto,gap-sm]
      [icon:name-file-text,size-12,color-dim]
      [text:size-sm,color-mid] ${props.path || 'Untitled'}
    [/grid]
    ${props.preview ? `[text:size-sm,color-dim] ${props.preview}` : ''}
    ${props.matches ? `[badge:variant-accent] ${props.matches} matches` : ''}
  [/stack]
[/card]`;

    case 'tag-group':
      const tags = props.tags ? props.tags.split('|') : [];
      return `[grid:cols-auto-fit,min-80px,gap-sm]
  ${tags.map(tag => {
    const [name, count] = tag.split(':');
    return `[card]
    [grid:cols-auto,gap-sm]
      [icon:name-hash,size-12,color-dim]
      [text:size-sm,color-mid] ${name}
      ${count ? `[text:size-sm,color-muted] (${count})` : ''}
    [/grid]
  [/card]`;
  }).join('\n  ')}
[/grid]`;

    case 'stat-card':
      return `[card]
  [stack:gap-xs]
    [text:size-xl,color-bright] ${props.value || '0'}
    [text:size-sm,color-dim] ${props.label || 'Stat'}
  [/stack]
[/card]`;

    case 'file-list-item':
      return `[grid:cols-auto,gap-sm,align-center]
  [icon:name-${props.icon || 'file'},size-12,color-dim]
  [text:size-sm,color-mid] ${props.path || 'Untitled'}
  ${props.badge ? `[badge] ${props.badge}` : ''}
[/grid]`;

    default:
      return null;
  }
};

// ENHANCED: Grammar Parser with validation
export const parseGrammar = (grammar) => {
  // First pass: expand semantic patterns
  let expanded = grammar;
  const semanticPattern = /\[(file-result|search-result|tag-group|stat-card|file-list-item):[^\]]+\]/g;
  const matches = grammar.match(semanticPattern);
  
  if (matches) {
    matches.forEach(match => {
      const expandedPattern = expandSemanticPattern(match);
      if (expandedPattern) {
        expanded = expanded.replace(match, expandedPattern);
      }
    });
  }
  
  const normalized = expanded
    .replace(/\]\s*\[/g, ']\n[')
    .trim();
    
  const lines = normalized.split('\n');
  const elements = [];
  const stack = [];
  
  for (let line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    
    if (trimmed.startsWith('[/')) {
      if (stack.length > 0) {
        const completed = stack.pop();
        if (stack.length === 0) {
          elements.push(completed);
        } else {
          stack[stack.length - 1].children.push(completed);
        }
      }
      continue;
    }
    
    const tagMatch = trimmed.match(/^\[(\w+)(?::([^\]]+))?\]\s*(.*)/);
    if (tagMatch) {
      const [, type, propsStr, contentAfterTag] = tagMatch;
      const props = parseProps(propsStr);
      
      const element = { type, props, children: [], content: contentAfterTag.trim() || '' };
      
      // Validation
      if (props.cols === 'auto' && props.min) {
        console.warn('Grid: "auto" cols with "min" prop may not work as expected');
      }
      
      const containerTypes = ['grid', 'container', 'stack', 'card'];
      if (!contentAfterTag && containerTypes.includes(type)) {
        stack.push(element);
      } else if (stack.length > 0) {
        stack[stack.length - 1].children.push(element);
      } else {
        elements.push(element);
      }
    }
  }
  
  while (stack.length > 0) {
    const completed = stack.pop();
    if (stack.length === 0) {
      elements.push(completed);
    } else {
      stack[stack.length - 1].children.push(completed);
    }
  }
  
  return elements;
};

// ENHANCED: Grammar Renderer with better action handling
export const GrammarRenderer = ({ grammar, onAction }) => {
  const elements = parseGrammar(grammar);
  
  const handleAction = (actionData) => {
    if (onAction) {
      onAction({
        type: actionData.action || actionData.type,
        data: actionData.data ? JSON.parse(actionData.data) : {},
        target: actionData.target,
        props: actionData
      });
    }
  };
  
  const renderElement = (element, index) => {
    const { type, props, content, children } = element;
    
    switch (type) {
      case 'text':
        return <Text key={index} {...props}>{content}</Text>;
      
      case 'icon':
        return <Icon key={index} name={props.name} {...props} />;
      
      case 'badge':
        return <Badge key={index} variant={props.variant}>{content}</Badge>;
      
      case 'card':
        return (
          <Card key={index} hover={props.hover} onClick={props.action ? () => handleAction(props) : null}>
            {content && <Text>{content}</Text>}
            {children.map((child, i) => renderElement(child, i))}
          </Card>
        );
      
      case 'stack':
        return (
          <Stack key={index} direction={props.direction} gap={props.gap} align={props.align}>
            {content && <Text>{content}</Text>}
            {children.map((child, i) => renderElement(child, i))}
          </Stack>
        );
      
      case 'grid':
      case 'container':
        return (
          <Grid key={index} {...props}>
            {content && <Text>{content}</Text>}
            {children.map((child, i) => renderElement(child, i))}
          </Grid>
        );
      
      case 'button':
        return (
          <Button 
            key={index} 
            {...props} 
            ariaLabel={props['aria-label']}
            onClick={() => handleAction(props)}
          >
            {content}
          </Button>
        );
      
      case 'link':
        return (
          <Link 
            key={index} 
            icon={props.icon}
            onClick={() => handleAction(props)}
          >
            {content}
          </Link>
        );
      
      case 'divider':
        return <Divider key={index} {...props} />;
      
      case 'listitem':
        return (
          <ListItem key={index} {...props}>
            {content && <Text size="sm" color="mid">{content}</Text>}
            {children.map((child, i) => renderElement(child, i))}
          </ListItem>
        );
      
      case 'status':
        return <Status key={index} type={props.type}>{content}</Status>;
      
      case 'spinner':
        return <Spinner key={index} />;
      
      default:
        console.warn(`Unknown element type: ${type}`);
        return null;
    }
  };
  
  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: tokens.spacing.md }}>
      <style>{`
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
      `}</style>
      {elements.map((el, i) => renderElement(el, i))}
    </div>
  );
};

// Demo Component
export default function Demo() {
  const [activeTab, setActiveTab] = useState('semantic');
  const [grammar, setGrammar] = useState(`[file-result:path-/Projects/Website Redesign.md,tags-#project #design,modified-2024-03-15]`);
  const [lastAction, setLastAction] = useState(null);

  const handleAction = (action) => {
    setLastAction(action);
    console.log('Action triggered:', action);
  };

  const semanticExamples = {
    fileResult: {
      name: 'File Result (Semantic)',
      grammar: `[text:size-sm,color-mid] ✦ I found the file you were looking for:
[divider:space-md]
[file-result:path-/Projects/Website Redesign.md,tags-#project #design #2024,modified-2024-03-15]`
    },
    searchResult: {
      name: 'Search Results (Semantic)',
      grammar: `[text:size-sm,color-mid] ✦ I found 2 files mentioning "Emma":
[divider:space-md]
[stack:gap-md]
  [search-result:path-/Journal/2024-03-15.md,preview-Emma had her first birthday party today...,matches-3]
  [search-result:path-/Projects/Website.md,preview-Meeting with Emma to discuss design direction...,matches-2]
[/stack]`
    },
    tagGroup: {
      name: 'Tag Analysis (Semantic)',
      grammar: `[text:size-sm,color-mid] ✦ Here are the most commonly used tags in your vault:
[divider:space-md]
[tag-group:tags-project:34|design:21|website:12|2024:8]`
    },
    statCards: {
      name: 'Vault Statistics (Semantic)',
      grammar: `[text:size-sm,color-mid] ✦ Here's an overview of your vault:
[divider:space-md]
[grid:cols-2,gap-lg]
  [stat-card:value-1247,label-Total notes]
  [stat-card:value-34,label-Tags]
  [stat-card:value-23,label-Orphaned]
  [stat-card:value-5,label-Modified today]
[/grid]`
    },
    fileList: {
      name: 'Recent Files (Semantic)',
      grammar: `[text:size-sm,color-mid] ✦ These are your most recently modified files:
[divider:space-md]
[card]
  [stack:gap-sm]
    [text:size-sm,color-bright] Recent files
    [divider:space-sm]
    [file-list-item:path-/Projects/Website.md,icon-file-text]
    [file-list-item:path-/Projects/Mobile App.md,icon-file-text,badge-Modified]
    [file-list-item:path-/Archive/Old Notes.md,icon-archive]
  [/stack]
[/card]
[grid:cols-auto,gap-sm]
  [button:icon-folder,action-browse] Browse all
  [button:icon-plus,action-create] New file
[/grid]`
    },
    approval: {
      name: 'Approval Request',
      grammar: `[text:size-sm,color-mid] ✦ I can update the frontmatter for these 3 files. Would you like me to proceed?
[divider:space-md]
[card]
  [stack:gap-sm]
    [grid:cols-auto,gap-sm]
      [icon:name-alert-circle,size-14]
      [text:size-sm,color-bright] Modify 3 files
    [/grid]
    [text:size-sm,color-dim] This will add "status: active" to all project files in /Projects
  [/stack]
[/card]
[stack:direction-horizontal,gap-sm]
  [button:icon-check,action-approve,aria-label-Approve modification] Approve
  [button:icon-x,action-reject,aria-label-Reject modification] Deny
[/stack]`
    }
  };

  const componentExamples = {
    badges: {
      name: 'Badges',
      grammar: `[stack:direction-horizontal,gap-sm]
  [badge:variant-default] Default
  [badge:variant-accent] Accent
  [badge:variant-success] Success
  [badge:variant-error] Error
[/stack]`
    },
    cards: {
      name: 'Cards with Actions',
      grammar: `[card]
  [stack:gap-sm]
    [text:size-sm,color-bright] Project Overview
    [text:size-sm,color-dim] 12 files • Last updated today
  [/stack]
[/card]
[grid:cols-auto,gap-sm]
  [button:icon-external-link,action-open] Open
  [button:icon-edit,action-edit] Edit
[/grid]`
    },
    stacks: {
      name: 'Stacks',
      grammar: `[card]
  [stack:gap-md]
    [text:size-sm,color-bright] Vertical Stack
    [stack:direction-horizontal,gap-sm]
      [badge] One
      [badge] Two
      [badge] Three
    [/stack]
    [text:size-sm,color-dim] Nested horizontal stack inside vertical
  [/stack]
[/card]`
    },
    links: {
      name: 'Links',
      grammar: `[stack:gap-sm]
  [link:icon-external-link] Open in new window
  [link:icon-folder] Browse folder
  [link:icon-search] Search files
[/stack]`
    },
    actions: {
      name: 'Actions & ARIA',
      grammar: `[card]
  [stack:gap-sm]
    [text:size-sm,color-bright] Interactive elements
    [text:size-sm,color-dim] Click buttons to test actions
  [/stack]
[/card]
[stack:direction-horizontal,gap-sm]
  [button:icon-check,action-approve,aria-label-Approve modification] Approve
  [button:icon-x,action-reject,aria-label-Reject modification] Reject
[/stack]`
    }
  };

  return (
    <div style={{
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
      background: tokens.colors.bgBase,
      color: tokens.colors.textMid,
      minHeight: '100vh',
      padding: '24px'
    }}>
      <div style={{ maxWidth: '900px', margin: '0 auto' }}>
        <Text size="xl" color="bright" style={{ marginBottom: '8px' }}>
          Enhanced Grammar UI System
        </Text>
        <Text size="sm" color="dim" style={{ marginBottom: '24px' }}>
          Two-tier grammar with semantic shortcuts & new components
        </Text>

        <Grid cols="auto" gap="sm" style={{ marginBottom: '24px' }}>
          <Button primary={activeTab === 'semantic'} onClick={() => setActiveTab('semantic')}>
            Semantic Layer
          </Button>
          <Button primary={activeTab === 'components'} onClick={() => setActiveTab('components')}>
            New Components
          </Button>
          <Button primary={activeTab === 'editor'} onClick={() => setActiveTab('editor')}>
            Editor
          </Button>
        </Grid>

        {lastAction && (
          <Status type="info" style={{ marginBottom: '16px' }}>
            Last action: {lastAction.type} {lastAction.target ? `(${lastAction.target})` : ''}
          </Status>
        )}

        {activeTab === 'semantic' && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '32px' }}>
            {Object.entries(semanticExamples).map(([key, { name, grammar }]) => (
              <div key={key}>
                <Text size="lg" color="bright" style={{ marginBottom: '12px' }}>
                  {name}
                </Text>
                
                <Text size="sm" color="dim" style={{ marginBottom: '8px' }}>
                  Grammar:
                </Text>
                <pre style={{
                  background: tokens.colors.bgSurface,
                  border: `1px solid ${tokens.colors.border}`,
                  borderRadius: tokens.radius.md,
                  padding: tokens.spacing.lg,
                  fontSize: tokens.fontSize.xs,
                  color: tokens.colors.textMid,
                  overflow: 'auto',
                  marginBottom: '16px',
                  fontFamily: 'monospace',
                  whiteSpace: 'pre-wrap'
                }}>
                  {grammar}
                </pre>
                
                <Text size="sm" color="dim" style={{ marginBottom: '8px' }}>
                  Rendered:
                </Text>
                <GrammarRenderer grammar={grammar} onAction={handleAction} />
              </div>
            ))}
          </div>
        )}

        {activeTab === 'components' && (
          <div style={{ display: 'flex', flexDirection: 'column', gap: '32px' }}>
            {Object.entries(componentExamples).map(([key, { name, grammar }]) => (
              <div key={key}>
                <Text size="lg" color="bright" style={{ marginBottom: '12px' }}>
                  {name}
                </Text>
                
                <Text size="sm" color="dim" style={{ marginBottom: '8px' }}>
                  Grammar:
                </Text>
                <pre style={{
                  background: tokens.colors.bgSurface,
                  border: `1px solid ${tokens.colors.border}`,
                  borderRadius: tokens.radius.md,
                  padding: tokens.spacing.lg,
                  fontSize: tokens.fontSize.xs,
                  color: tokens.colors.textMid,
                  overflow: 'auto',
                  marginBottom: '16px',
                  fontFamily: 'monospace',
                  whiteSpace: 'pre-wrap'
                }}>
                  {grammar}
                </pre>
                
                <Text size="sm" color="dim" style={{ marginBottom: '8px' }}>
                  Rendered:
                </Text>
                <GrammarRenderer grammar={grammar} onAction={handleAction} />
              </div>
            ))}
          </div>
        )}

        {activeTab === 'editor' && (
          <>
            <Text size="sm" color="dim" style={{ marginBottom: '8px' }}>
              Try a semantic pattern:
            </Text>
            <textarea
              value={grammar}
              onChange={(e) => setGrammar(e.target.value)}
              placeholder="Try: [file-result:path-/My File.md,tags-#test,modified-Today]"
              style={{
                width: '100%',
                minHeight: '150px',
                background: tokens.colors.bgSurface,
                border: `1px solid ${tokens.colors.border}`,
                borderRadius: tokens.radius.md,
                padding: tokens.spacing.lg,
                color: tokens.colors.textMid,
                fontSize: tokens.fontSize.sm,
                fontFamily: 'monospace',
                resize: 'vertical',
                marginBottom: '16px'
              }}
            />
            
            <Text size="sm" color="dim" style={{ marginBottom: '16px' }}>
              Rendered:
            </Text>
            
            <GrammarRenderer grammar={grammar} onAction={handleAction} />
          </>
        )}
      </div>
    </div>
  );
}
